/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
import { AspectRatioValue } from "./components/aspect-ratio/aspect-ratio.types";
import { CardElevation } from "./components/card/card/card.types";
import { CropperMode, CropperResizer, CropperResizerShape, CropperResponsive, CropperShape, CropperValue, CropperView, CropperZoomable, CropperZoomData } from "./components/cropper/cropper.types";
import { DialogFullscreen, DialogPlacement, DialogPortalStrategy, DialogPortalTarget, DialogSize } from "./components/dialog/dialog/dialog.types";
import { DividerSize, DividerType } from "./components/divider/divider.types";
import { DrawerBackdrop, DrawerBreakpoint, DrawerPlacement } from "./components/drawer/drawer/drawer.types";
import { GridAlignContent, GridAlignItems, GridGutter, GridJustifyContent, GridWrap } from "./components/grid/grid/grid.types";
import { GridItemAlignSelf, GridItemColumn, GridItemOffset, GridItemOrder } from "./components/grid/grid-item/grid-item.types";
import { IntersectionBehavior } from "./components/intersection/intersection.types";
import { MenuAlignX, MenuAlignY, MenuGrowX, MenuGrowY } from "./components/menu/menu.types";
import { PortalStrategy, PortalTarget } from "@app/utils";
import { ScrollIndicatorSource } from "./components/scroll-indicator/scroll-indicator.types";
import { SpinnerSize, SpinnerType } from "./components/spinner/spinner.types";
import { StickyState, StickyTop } from "./components/sticky/sticky.types";
import { ToastPlacement, ToastType } from "./components/toast/toast/toast.types";
import { TooltipAnimation, TooltipArrow, TooltipPlacement, TooltipTrigger } from "./components/tooltip/tooltip.types";
import { TransitionDirection, TransitionDuration, TransitionRepeat } from "./components/transition/transition.types";
import { SubscribeType } from "./utils/tunnel/tunnel.types";
export namespace Components {
    interface PlusAspectRatio {
        /**
          * Specifies the ratio.
         */
        "value"?: AspectRatioValue;
    }
    interface PlusBottomNavigation {
        /**
          * TODO
         */
        "fixed"?: boolean;
        /**
          * TODO
         */
        "grow"?: boolean;
        /**
          * TODO
         */
        "hideOnScroll"?: boolean;
        /**
          * TODO
         */
        "labelPosition"?: 'bottom' | 'side';
        /**
          * TODO: https://vuetifyjs.com/en/components/bottom-navigation/#scroll-threshold
         */
        "scrollTarget": string;
        /**
          * TODO: https://vuetifyjs.com/en/components/bottom-navigation/#scroll-threshold
         */
        "scrollThreshold"?: number;
        /**
          * TODO https://vuetifyjs.com/en/components/bottom-navigation/#shift https://vuetifyjs.com/en/api/v-bottom-navigation/#props-shift
         */
        "shift"?: boolean;
        /**
          * TODO
         */
        "value"?: any;
    }
    interface PlusBottomNavigationItem {
        /**
          * TODO
         */
        "disabled"?: boolean;
        /**
          * TODO
         */
        "value"?: any;
    }
    interface PlusBreadcrumb {
        /**
          * For localization purposes, you can use the provided translations.
         */
        "expanderText"?: string;
        /**
          * Specifies Maximum items that is allowed to be displayed.
         */
        "max"?: number;
        /**
          * The expander button is displayed when the number of the items reached the maximum limit.  The offset property specifies the position of the expander button.
         */
        "offset"?: number;
        /**
          * You can use HTML elements, Custom separator, or SVG icon.
         */
        "separator"?: string;
    }
    interface PlusCard {
        /**
          * If you want the card to have shadow, use the elevation property,  And select the property value between `1` and `24`.
         */
        "elevation"?: CardElevation;
        /**
          * Use the flat property to neutralize elevation.
         */
        "flat"?: boolean;
        /**
          * If you want the card to have border, use the outlined property.
         */
        "outlined"?: boolean;
        /**
          * Use tile property to neutralize border-radius.
         */
        "tile"?: boolean;
    }
    interface PlusCardBody {
    }
    interface PlusCardFooter {
    }
    interface PlusCardHeader {
    }
    interface PlusClickOutside {
        /**
          * Disable the component.
         */
        "disabled"?: boolean;
        /**
          * The callback occurs only once.
         */
        "once"?: boolean;
    }
    interface PlusCropper {
        /**
          * A number between 0 and 1. Define the automatic cropping area size.
         */
        "area"?: number;
        /**
          * Defines the initial aspect ratio of the viewport.
         */
        "aspectRatio"?: number;
        /**
          * Shows the black modal above the image and under the viewport.
         */
        "backdrop"?: boolean;
        /**
          * Shows the grid background of the container.
         */
        "background"?: boolean;
        /**
          * Disables the cropper.
         */
        "disabled"?: boolean;
        /**
          * Flip horizontal.
         */
        "flipX": () => Promise<void>;
        /**
          * Flip vertical.
         */
        "flipY": () => Promise<void>;
        /**
          * Shows the dashed lines above the viewport.
         */
        "guides"?: boolean;
        /**
          * Shows the center indicator above the viewport.
         */
        "indicator"?: boolean;
        /**
          * Defines the cropping mode of the cropper.
          * @value crop - Creates a new viewport and allows you to move and resize it.
          * @value move - moves the canvas and viewport.
         */
        "mode"?: CropperMode;
        /**
          * Move the canvas with relative offsets.
          * @param offsetX - Moving size (px) in the `horizontal` direction. Use `null` to ignore this.
          * @param offsetY - Moving size (px) in the `vertical` direction. Use `null` to ignore this.
         */
        "move": (offsetX?: number, offsetY?: number) => Promise<void>;
        /**
          * Move the canvas to an absolute point.
          * @param x - The `left` value of the canvas. Use `null` to ignore this.
          * @param y - The `top` value of the canvas. Use `null` to ignore this.
         */
        "moveTo": (x?: number, y?: number) => Promise<void>;
        /**
          * Reset the image and viewport to their initial states.
         */
        "reset": () => Promise<void>;
        /**
          * Enables to resize the viewport by dragging (Works when the value of the `mode` property is `crop`).
          * @value main - Enables to resize the viewport by dragging on the Sides.
          * @value edge - Enables to resize the viewport by dragging on the vertices.
          * @value both - Enables to resize the viewport by dragging on the Sides and vertices.
         */
        "resizer"?: CropperResizer;
        /**
          * Specifies the shape of the resizer.
         */
        "resizerShape"?: CropperResizerShape;
        /**
          * Re-renders the cropper when resizing the window.
          * @value reset - Restores the cropped area after resizing the window.
         */
        "responsive"?: CropperResponsive;
        /**
          * Rotate the image with a relative degree.
         */
        "rotate": (degree: number) => Promise<void>;
        /**
          * Rotate the image to an absolute degree.
         */
        "rotateTo": (degree: number) => Promise<void>;
        /**
          * Specifies the shape of the viewport.
         */
        "shape"?: CropperShape;
        /**
          * Replace the image's src and rebuild the cropper.
         */
        "src"?: string;
        /**
          * Gets `base64` from the cropped image.
         */
        "toBase64": () => Promise<string>;
        /**
          * Gets `blob` value from the cropped image.
         */
        "toBlob": () => Promise<Blob>;
        /**
          * Gets `canvas` from the cropped image.
         */
        "toCanvas": () => Promise<HTMLCanvasElement>;
        /**
          * Gets `blob url` from the cropped image.
         */
        "toURL": () => Promise<string>;
        /**
          * The previous cropped data if you had stored, will be passed to value automatically when initialized.
         */
        "value"?: CropperValue;
        /**
          * Define the view mode of the cropper. If you set viewMode to `none`, the viewport can extend  outside the canvas, while a value of `fit`, `contain` or `cover` will restrict the viewport  to the size of the canvas. A viewMode of `contain` or `cover` will additionally restrict the  canvas to the container. Note that if the proportions of the canvas and the container are  the same, there is no difference between `contain` and `cover`.
          * @value contain - restrict the minimum canvas size to fit within the container. If the            proportions of the canvas and the container differ, the minimum canvas will be            surrounded by extra space in one of the dimensions.
          * @value cover   - restrict the minimum canvas size to fill fit the container. If the proportions            of the canvas and the container are different, the container will not be able            to fit the whole canvas in one of the dimensions.
          * @value fit     - restrict the viewport to not exceed the size of the canvas.
          * @value none    - no restrictions.
         */
        "view"?: CropperView;
        /**
          * Zoom the canvas with a relative ratio.
         */
        "zoom": (ratio: number) => Promise<void>;
        /**
          * Defines zoom ratio when zooming the image by wheeling mouse.
         */
        "zoomRatio"?: number;
        /**
          * Zoom the canvas to an absolute ratio.
         */
        "zoomTo": (ratio: number) => Promise<void>;
        /**
          * Enables to zoom the image.
          * @value false - Unable to zoom the image.
          * @value true  - Enables to zoom the image by touching and wheeling mouse.
          * @value touch - Enables to zoom the image by touching.
          * @value wheel - Enables to zoom the image by wheeling mouse.
          * @
         */
        "zoomable"?: CropperZoomable;
    }
    interface PlusDialog {
        /**
          * TODO
         */
        "animation"?: string;
        /**
          * Activate the dialog's backdrop to show or not.
         */
        "backdrop"?: boolean;
        /**
          * This property helps you to attach which dialog toggler controls the dialog.  It doesn't matter where the dialog toggler is.  You can put the dialog's toggler inside or outside of the dialog.  Read more about connectors [here](https://htmlplus.io/features/connector).
         */
        "connector"?: string;
        /**
          * Set the height of the dialog as much as the screen's height.
         */
        "fullHeight"?: boolean;
        /**
          * Set the width of the dialog as much as the screen's width.
         */
        "fullWidth"?: boolean;
        /**
          * Set both width and height of the dialog to occupy the screen size.
         */
        "fullscreen"?: DialogFullscreen;
        /**
          * Closes the dialog when `escape` key is pressed.
         */
        "keyboard"?: boolean;
        /**
          * Control dialog to show or not.
         */
        "open"?: boolean;
        /**
          * It prevents the dialog from closing on clicking outside of the element.
         */
        "persistent"?: boolean;
        /**
          * Specifies where to show the dialog box by choosing two values, one for horizontal and another for vertical. Horizontal has a range of `left`, `center`, `right`, `start`, `end`, and vertical values are `top`, `center` and `bottom`.
         */
        "placement"?: DialogPlacement;
        /**
          * Enables or disables the portal.
          * @experimental
         */
        "portal"?: boolean;
        /**
          * Specifies the position of the dialog.
          * @experimental
         */
        "portalStrategy"?: DialogPortalStrategy;
        /**
          * Specifies the position of the dialog relative to the target.
          * @experimental
         */
        "portalTarget"?: DialogPortalTarget;
        /**
          * It makes the user able to scroll the content by adding a scroll beside it.
         */
        "scrollable"?: boolean;
        /**
          * Determine the width of the dialog.
         */
        "size"?: DialogSize;
        /**
          * Removes the margin around the dialog's content.
         */
        "sticky"?: boolean;
    }
    interface PlusDialogBody {
        /**
          * It makes the user able to scroll the content by adding a scroll beside it.
         */
        "scrollable"?: boolean;
    }
    interface PlusDialogContent {
        /**
          * It makes the user able to scroll the content by adding a scroll beside it.
         */
        "scrollable"?: boolean;
    }
    interface PlusDialogFooter {
    }
    interface PlusDialogHeader {
    }
    interface PlusDialogToggler {
        /**
          * This property helps you to attach which dialog this toggler controls.  It doesn't matter where the dialog toggler is.  You can put the dialog's toggler inside or outside of the dialog.  Read more about connectors [here](https://htmlplus.io/features/connector).
         */
        "connector"?: string;
    }
    interface PlusDivider {
        /**
          * Determines the width of the divider.
         */
        "size"?: DividerSize;
        /**
          * Specifies different divider styles.
         */
        "type"?: DividerType;
        /**
          * You can use vertical property for vertical division.
         */
        "vertical"?: boolean;
    }
    interface PlusDrawer {
        /**
          * Activate the drawer's backdrop to show or not.
         */
        "backdrop"?: DrawerBackdrop;
        /**
          * Sets the mobile breakpoint to apply alternate styles for mobile devices when the breakpoint value is met.
         */
        "breakpoint"?: DrawerBreakpoint;
        /**
          * This property helps you to attach which drawer toggler controls the drawer.  It doesn't matter where the drawer toggler is.  You can put the drawer's toggler inside or outside of the drawer.  Read more about connectors [here](https://htmlplus.io/features/connector).
         */
        "connector"?: string;
        /**
          * It controls the flexibility of the drawer's width. If yes, the width of the drawer can be reduced. If false doesn't allow the width of the drawer to reduce.
         */
        "flexible"?: boolean;
        /**
          * Set the width of drawer to the minimum size you specified for the `mini-size` property.
         */
        "mini"?: boolean;
        /**
          * Sets the minimum width size of the drawer.
         */
        "miniSize"?: string;
        /**
          * Control drawer to show or not.
         */
        "open"?: boolean;
        /**
          * If true, don't allow the drawer to be closed by clicking outside of the drawer. If false, the drawer will be closed by clicking outside of it.
         */
        "persistent"?: boolean;
        /**
          * Specifies where the drawer will open.
         */
        "placement"?: DrawerPlacement;
        /**
          * Determine the width of the drawer.
         */
        "size"?: string;
        /**
          * On default the drawer is considered as a part of the main container. it pushes the other contents on opening. If true it will be opened over other contents and doesn't affect other contents. A temporary drawer sits above its application and uses a backdrop to darken the background.
         */
        "temporary"?: boolean | 'on-breakpoint';
    }
    interface PlusDrawerToggler {
        /**
          * This property helps you to attach which drawer this toggler controls.  It doesn't matter where the drawer toggler is.  You can put the drawer's toggler inside or outside of the drawer.  Read more about connectors [here](https://htmlplus.io/features/connector).
         */
        "connector"?: string;
    }
    interface PlusGrid {
        /**
          * Aligns contents vertically across all rows (It overrides alignItems).
         */
        "alignContent"?: GridAlignContent;
        /**
          * Aligns contents vertically across all rows for large display sizes (It overrides alignItemsLg).
         */
        "alignContentLg"?: GridAlignContent;
        /**
          * Aligns contents vertically across all rows for medium display sizes (It overrides alignItemsMd).
         */
        "alignContentMd"?: GridAlignContent;
        /**
          * Aligns contents vertically across all rows for small display sizes (It overrides alignItemsSm).
         */
        "alignContentSm"?: GridAlignContent;
        /**
          * Aligns contents vertically across all rows for extra-large display sizes (It overrides alignItemsXl).
         */
        "alignContentXl"?: GridAlignContent;
        /**
          * Aligns contents vertically across all rows for extra-small display sizes (It overrides alignItemsXs).
         */
        "alignContentXs"?: GridAlignContent;
        /**
          * Aligns contents vertically across all rows for extra-extra-large display sizes (It overrides alignItemsXXl).
         */
        "alignContentXxl"?: GridAlignContent;
        /**
          * Aligns contents vertically inside their own row.
         */
        "alignItems"?: GridAlignItems;
        /**
          * Aligns contents vertically inside their own row for large display sizes.
         */
        "alignItemsLg"?: GridAlignItems;
        /**
          * Aligns contents vertically inside their own row for medium display sizes.
         */
        "alignItemsMd"?: GridAlignItems;
        /**
          * Aligns contents vertically inside their own row for small display sizes.
         */
        "alignItemsSm"?: GridAlignItems;
        /**
          * Aligns contents vertically inside their own row for extra-large display sizes.
         */
        "alignItemsXl"?: GridAlignItems;
        /**
          * Aligns contents vertically inside their own row for extra-small display sizes.
         */
        "alignItemsXs"?: GridAlignItems;
        /**
          * Aligns contents vertically inside their own row for extra-extra-large display sizes.
         */
        "alignItemsXxl"?: GridAlignItems;
        /**
          * Adds a gap between contents to make space between them vertically and horizontally.
         */
        "gutter"?: GridGutter;
        /**
          * Adds a gap between contents to make space between them horizontally.
         */
        "gutterX"?: GridGutter;
        /**
          * Adds a gap between contents to make space between them vertically.
         */
        "gutterY"?: GridGutter;
        /**
          * Justifies contents horizontally.
         */
        "justifyContent"?: GridJustifyContent;
        /**
          * Justifies contents horizontally for large display sizes.
         */
        "justifyContentLg"?: GridJustifyContent;
        /**
          * Justifies contents horizontally for medium display sizes.
         */
        "justifyContentMd"?: GridJustifyContent;
        /**
          * Justifies contents horizontally for small display sizes.
         */
        "justifyContentSm"?: GridJustifyContent;
        /**
          * Justifies contents horizontally for extra-large display sizes.
         */
        "justifyContentXl"?: GridJustifyContent;
        /**
          * Justifies contents horizontally for extra-small display sizes.
         */
        "justifyContentXs"?: GridJustifyContent;
        /**
          * Justifies contents horizontally for extra-extra-large display sizes.
         */
        "justifyContentXxl"?: GridJustifyContent;
        /**
          * Reverses the flow of contents from left-to-right to right-to-left, or vice-versa.
         */
        "reverse"?: boolean;
        /**
          * Changes the flow of contents from left-to-right to top-to-down.
         */
        "vertical"?: boolean;
        /**
          * Controls allowing the container to wrap the content or not if the cumulative width size of contents is more than the twelve-column width.
         */
        "wrap"?: GridWrap;
        /**
          * Controls allowing the container to wrap the content or not if the cumulative width size of contents is more than the twelve-column width for large screen devices.
         */
        "wrapLg"?: GridWrap;
        /**
          * Controls allowing the container to wrap the content or not if the cumulative width size of contents is more than the twelve-column width for medium screen devices.
         */
        "wrapMd"?: GridWrap;
        /**
          * Controls allowing the container to wrap the content or not if the cumulative width size of contents is more than the twelve-column width for small screen devices.
         */
        "wrapSm"?: GridWrap;
        /**
          * Controls allowing the container to wrap the content or not if the cumulative width size of contents is more than the twelve-column width for extra-large screen devices.
         */
        "wrapXl"?: GridWrap;
        /**
          * Controls allowing the container to wrap the content or not if the cumulative width size of contents is more than the twelve-column width for extra-small screen devices.
         */
        "wrapXs"?: GridWrap;
        /**
          * Controls allowing the container to wrap the content or not if the cumulative width size of contents is more than the twelve-column width for extra-extra-large screen devices.
         */
        "wrapXxl"?: GridWrap;
    }
    interface PlusGridItem {
        /**
          * Aligns the grid-item vertically in its container (grid). It overrides the align-items property of its parent.
         */
        "alignSelf"?: GridItemAlignSelf;
        /**
          * Aligns the grid-item vertically in its container (grid) for large display sizes. It also applies to larger breakpoints and display sizes while they are not specified. (It overrides the align-items property of its parent just for large breakpoints).
         */
        "alignSelfLg"?: GridItemAlignSelf;
        /**
          * Aligns the grid-item vertically in its container (grid) for medium display sizes. It also applies to larger breakpoints and display sizes while they are not specified. (It overrides the align-items property of its parent just for medium breakpoints).
         */
        "alignSelfMd"?: GridItemAlignSelf;
        /**
          * Aligns the grid-item vertically in its container (grid) for small display sizes. It also applies to larger breakpoints and display sizes while they are not specified. (It overrides the align-items property of its parent just for small breakpoints).
         */
        "alignSelfSm"?: GridItemAlignSelf;
        /**
          * Aligns the grid-item vertically in its container (grid) for extra-large display sizes. It also applies to larger breakpoints and display sizes while they are not specified. (It overrides the align-items property of its parent just for extra-large breakpoints).
         */
        "alignSelfXl"?: GridItemAlignSelf;
        /**
          * Aligns the grid-item vertically in its container (grid) for extra-small display sizes. It also applies to larger breakpoints and display sizes while they are not specified. (It overrides the align-items property of its parent just for extra-small breakpoints).
         */
        "alignSelfXs"?: GridItemAlignSelf;
        /**
          * Aligns the grid-item vertically in its container (grid) for extra-extra-large display sizes. It also applies to larger breakpoints and display sizes while they are not specified. (It overrides the align-items property of its parent just for extra-extra-large breakpoints).
         */
        "alignSelfXxl"?: GridItemAlignSelf;
        /**
          * Hides the grid-item in all display sizes.
         */
        "hide"?: boolean;
        /**
          * Hides the grid-item in large display sizes (desktop).
         */
        "hideLg"?: boolean;
        /**
          * Hides the grid-item in large and smaller display sizes.
         */
        "hideLgDown"?: boolean;
        /**
          * Hides the grid-item in large and larger display sizes.
         */
        "hideLgUp"?: boolean;
        /**
          * Hides the grid-item in medium display sizes (tablets).
         */
        "hideMd"?: boolean;
        /**
          * Hides the grid-item in medium and smaller display sizes.
         */
        "hideMdDown"?: boolean;
        /**
          * Hides the grid-item in medium and larger display sizes.
         */
        "hideMdUp"?: boolean;
        /**
          * Hides the grid-item in small display sizes (landscape phones).
         */
        "hideSm"?: boolean;
        /**
          * Hides the grid-item in small and smaller display sizes.
         */
        "hideSmDown"?: boolean;
        /**
          * Hides the grid-item in small and larger display sizes.
         */
        "hideSmUp"?: boolean;
        /**
          * Hides the grid-item in extra-large display sizes (large desktops).
         */
        "hideXl"?: boolean;
        /**
          * Hides the grid-item in large and smaller display sizes.
         */
        "hideXlDown"?: boolean;
        /**
          * Hides the grid-item in large and larger display sizes.
         */
        "hideXlUp"?: boolean;
        /**
          * Hides the grid-item in extra-small display sizes (portrait phones).
         */
        "hideXs"?: boolean;
        /**
          * Hides the grid-item in extra-extra-large display sizes (larger desktops).
         */
        "hideXxl"?: boolean;
        /**
          * Hides the grid-item in large and smaller display sizes.
         */
        "hideXxlDown"?: boolean;
        /**
          * Specifies the number of columns for large viewports (desktop). It also determines the number of columns for bigger display sizes when the upper breakpoint (xl and xxl) is not specified.
         */
        "lg"?: GridItemColumn;
        /**
          * Specifies the number of columns for medium viewports (tablets). It also determines the number of columns for bigger display sizes when other upper breakpoints (lg, xl and xxl) are not specified.
         */
        "md"?: GridItemColumn;
        /**
          * Adds an offset space before the grid-item for large display sizes. It also applies to the larger breakpoint (xl) while that is not specified.
         */
        "offsetLg"?: GridItemOffset;
        /**
          * Adds an offset space before the grid-item for medium display sizes. It also applies to larger breakpoints and display sizes while they are not specified.
         */
        "offsetMd"?: GridItemOffset;
        /**
          * Adds an offset space before the grid-item for small display sizes. It also applies to larger breakpoints and display sizes while they are not specified.
         */
        "offsetSm"?: GridItemOffset;
        /**
          * Adds an offset space before the grid-item for extra-large display sizes.
         */
        "offsetXl"?: GridItemOffset;
        /**
          * Adds an offset space before the grid-item for extra-small display sizes. It also applies to larger breakpoints and display sizes while they are not specified.
         */
        "offsetXs"?: GridItemOffset;
        /**
          * Adds an offset space before the grid-item for extra-extra-large display sizes.
         */
        "offsetXxl"?: GridItemOffset;
        /**
          * Overrides the default order of the grid-item for large display sizes. It also applies to the larger breakpoint (xl) while that is not specified.
         */
        "orderLg"?: GridItemOrder;
        /**
          * Overrides the default order of the grid-item for medium display sizes. It also applies to larger breakpoints and display sizes while they are not specified.
         */
        "orderMd"?: GridItemOrder;
        /**
          * Overrides the default order of the grid-item for small display sizes. It also applies to larger breakpoints and display sizes while they are not specified.
         */
        "orderSm"?: GridItemOrder;
        /**
          * Overrides the default order of the grid-item for extra-large display sizes.
         */
        "orderXl"?: GridItemOrder;
        /**
          * Overrides the default order of the grid-item for extra-small display sizes. It also applies to larger breakpoints and display sizes while they are not specified.
         */
        "orderXs"?: GridItemOrder;
        /**
          * Overrides the default order of the grid-item for extra-extra-large display sizes.
         */
        "orderXxl"?: GridItemOrder;
        /**
          * Specifies the number of columns for small viewports (landscape phones). It also determines the number of columns for bigger display sizes when other upper breakpoints (md, lg, xl and xxl) are not specified.
         */
        "sm"?: GridItemColumn;
        /**
          * Specifies the number of columns for large viewports (large desktops). It also determines the number of columns for bigger display sizes when the upper breakpoint (xxl) is not specified.
         */
        "xl"?: GridItemColumn;
        /**
          * Specifies the number of columns for extra-small viewports (portrait phones). It also determines the number of columns for bigger display sizes when other upper breakpoints (sm, md, lg, xl and xxl) are not specified.
         */
        "xs"?: GridItemColumn;
        /**
          * Specifies the number of columns for extra-extra-large viewports (larger desktops).
         */
        "xxl"?: GridItemColumn;
    }
    interface PlusIntersection {
        /**
          * It specifies how intersection behaves with its children.
          * @value normal - It doesn't have any effect on its children and the life cycles happen normally.
          * @value appear - The children are removed from the first moment, and then they're brought back in when the element intersects with the viewport. In other words, the children are added to the DOM when the element intersects with the viewport and they are removed when the element leaves the viewport.
          * @value blink  - The children are removed from the DOM when the element intersects with the viewport and are brought back in the DOM immediately. With that said, it affects the life cycles of its children.
         */
        "behavior"?: IntersectionBehavior;
        /**
          * Disables the intersection's trigger.
         */
        "disabled"?: boolean;
        /**
          * It causes the callback to be called just once for the first time.
         */
        "once"?: boolean;
        /**
          * The element that is used as the viewport for checking visibility of the target. Must be the ancestor of the target.  Defaults to the browser viewport if not specified or if null.
         */
        "root"?: Element;
        /**
          * Margin around the root. Can have values similar to the CSS [margin](https://developer.mozilla.org/en-US/docs/Web/CSS/margin) property, e.g.  "10px 20px 30px 40px" (top, right, bottom, left). The values can be percentages.  This set of values serves to grow or shrink each side of the root element's bounding box before computing intersections.  Defaults to all zeros.
         */
        "rootMargin"?: string;
        /**
          * Either a single number or an array of numbers which indicate at what percentage of the target's visibility the observer's callback should be executed.  If you only want to detect when visibility passes the 50% mark, you can use a value of 0.5.  If you want the callback to run every time visibility passes another 25%, you would specify the array [0, 0.25, 0.5, 0.75, 1].  The default is 0 (meaning as soon as even one pixel is visible, the callback will be run).  A value of 1.0 means that the threshold isn't considered passed until every pixel is visible.
         */
        "threshold"?: number | number[];
    }
    interface PlusMenu {
        /**
          * TODO
         */
        "alignX"?: MenuAlignX;
        /**
          * TODO
         */
        "alignY"?: MenuAlignY;
        /**
          * TODO
         */
        "fixed"?: boolean;
        /**
          * TODO
         */
        "growX"?: MenuGrowX;
        /**
          * TODO
         */
        "growY"?: MenuGrowY;
        /**
          * TODO
         */
        "offsetX"?: string | number;
        /**
          * TODO
         */
        "offsetY"?: string | number;
        /**
          * TODO
         */
        "open"?: boolean;
        /**
          * TODO
         */
        "persistent"?: boolean;
        /**
          * TODO
         */
        "trigger"?: 'click' | 'hover';
    }
    interface PlusPortal {
        /**
          * Disables the portal.
         */
        "disabled"?: boolean;
        /**
          * Specifies the position of the portal content relative to the target.
         */
        "strategy"?: PortalStrategy;
        /**
          * Specifies the position of the portal content, It Can include css selectors, node or any html elements.
         */
        "target"?: PortalTarget;
    }
    interface PlusRipple {
    }
    interface PlusScrollIndicator {
        /**
          * Disables the event.
         */
        "disabled"?: boolean;
        /**
          * Source of scroll.
         */
        "source"?: ScrollIndicatorSource;
    }
    interface PlusSpinner {
        /**
          * Specifies the size of the spinner.
         */
        "size"?: SpinnerSize;
        /**
          * Specifies which variant of the spinner to use.
         */
        "type"?: SpinnerType;
    }
    interface PlusSticky {
        /**
          * Disables the sticky mode.
         */
        "disabled"?: boolean;
        /**
          * Specifies the space from top.
         */
        "top"?: StickyTop;
        /**
          * If you use `state` property or `plusChange` event, you shold set this property to `true`.
         */
        "watcher"?: boolean;
        /**
          * Specifies the z-index of the sticky.
         */
        "zIndex"?: number;
    }
    interface PlusSwitch {
        /**
          * Puts the switch in checked state
         */
        "checked"?: boolean;
        /**
          * Disables the switch
         */
        "disabled"?: boolean;
        /**
          * Change the appearance of the switch to put the text inside the switch
         */
        "inset"?: boolean;
        /**
          * Switches the location of yes and no options
         */
        "reverse"?: boolean;
    }
    interface PlusTabs {
        /**
          * TODO
         */
        "connector"?: string;
        /**
          * TODO
         */
        "value"?: string;
        /**
          * TODO
         */
        "vertical"?: boolean;
    }
    interface PlusTabsBar {
        /**
          * TODO
         */
        "grow"?: boolean;
        /**
          * TODO
         */
        "justify"?: 'start' | 'center' | 'end';
        /**
          * TODO
         */
        "reverse"?: boolean;
    }
    interface PlusTabsPanel {
        /**
          * TODO
         */
        "value"?: string;
    }
    interface PlusTabsPanels {
        /**
          * TODO
         */
        "connector"?: string;
    }
    interface PlusTabsTab {
        /**
          * TODO
         */
        "disabled"?: boolean;
        /**
          * TODO
         */
        "value"?: string;
    }
    interface PlusTemplate {
        /**
          * TODO
         */
        "disabled"?: boolean;
    }
    interface PlusToast {
        /**
          * TODO
         */
        "animation"?: string;
        /**
          * TODO
         */
        "duration"?: number;
        /**
          * TODO
         */
        "fullWidth"?: boolean;
        /**
          * TODO
         */
        "open"?: boolean;
        /**
          * TODO
         */
        "persistent"?: boolean;
        /**
          * TODO
         */
        "placement"?: ToastPlacement;
        /**
          * TODO
         */
        "reverse"?: boolean;
        /**
          * TODO
         */
        "type"?: ToastType;
    }
    interface PlusToastToggler {
        /**
          * This property helps you to attach which toast this toggler controls.  It doesn't matter where the toast toggler is.  You can put the toast's toggler inside or outside of the toast.  Read more about connectors [here](https://htmlplus.io/features/connector).
         */
        "connector"?: string;
    }
    interface PlusToolbar {
        /**
          * TODO
         */
        "disabled"?: boolean;
    }
    interface PlusToolbarSpacer {
        /**
          * TODO
         */
        "disabled"?: boolean;
    }
    interface PlusTooltip {
        /**
          * Tooltip animation.
         */
        "animation"?: TooltipAnimation;
        /**
          * Tooltip append to a element.
         */
        "appendTo"?: any;
        /**
          * Tooltip arrow model.
         */
        "arrow"?: TooltipArrow;
        /**
          * Delay for show tooltip.
         */
        "delay"?: number;
        /**
          * Tooltip disable.
         */
        "disabled"?: boolean;
        /**
          * Add fixed strategy to popper.
         */
        "fixed"?: boolean;
        /**
          * Add fixed strategy to popper.
         */
        "flip"?: boolean;
        /**
          * How to position the tooltip.
         */
        "placement"?: TooltipPlacement;
        /**
          * How tooltip is triggered, include click, hover, focus.
         */
        "trigger"?: TooltipTrigger;
    }
    interface PlusTransition {
        /**
          * Specifies the amount of delay before starting the animation to play.  This may be specified in either seconds `s` or milliseconds `ms`.
         */
        "delay"?: string;
        /**
          * Defines whether an animation should be played forwards, backwards or in alternate cycles.
         */
        "direction"?: TransitionDirection;
        /**
          * Specifies the length of time it will take to complete one cycle between two defined states. You can also use the reservation values `slower`, `slow`, `normal`, `fast` and `faster`.
         */
        "duration"?: TransitionDuration;
        /**
          * Specifies what kind of animation you want to play.  click [here](ROUTE:COMPONENT:TRANSITION:PROPERTY:NAME) to see the list of available animations.
         */
        "name": string;
        /**
          * Specifies the number of times the animation should be repeated after one complete cycle.
         */
        "repeat"?: TransitionRepeat;
    }
    interface PlusTunnelConsumer {
        "context": { [key: string]: any };
        "renderer": Function;
        "subscribe"?: SubscribeType;
    }
}
declare global {
    interface HTMLPlusAspectRatioElement extends Components.PlusAspectRatio, HTMLStencilElement {
    }
    var HTMLPlusAspectRatioElement: {
        prototype: HTMLPlusAspectRatioElement;
        new (): HTMLPlusAspectRatioElement;
    };
    interface HTMLPlusBottomNavigationElement extends Components.PlusBottomNavigation, HTMLStencilElement {
    }
    var HTMLPlusBottomNavigationElement: {
        prototype: HTMLPlusBottomNavigationElement;
        new (): HTMLPlusBottomNavigationElement;
    };
    interface HTMLPlusBottomNavigationItemElement extends Components.PlusBottomNavigationItem, HTMLStencilElement {
    }
    var HTMLPlusBottomNavigationItemElement: {
        prototype: HTMLPlusBottomNavigationItemElement;
        new (): HTMLPlusBottomNavigationItemElement;
    };
    interface HTMLPlusBreadcrumbElement extends Components.PlusBreadcrumb, HTMLStencilElement {
    }
    var HTMLPlusBreadcrumbElement: {
        prototype: HTMLPlusBreadcrumbElement;
        new (): HTMLPlusBreadcrumbElement;
    };
    interface HTMLPlusCardElement extends Components.PlusCard, HTMLStencilElement {
    }
    var HTMLPlusCardElement: {
        prototype: HTMLPlusCardElement;
        new (): HTMLPlusCardElement;
    };
    interface HTMLPlusCardBodyElement extends Components.PlusCardBody, HTMLStencilElement {
    }
    var HTMLPlusCardBodyElement: {
        prototype: HTMLPlusCardBodyElement;
        new (): HTMLPlusCardBodyElement;
    };
    interface HTMLPlusCardFooterElement extends Components.PlusCardFooter, HTMLStencilElement {
    }
    var HTMLPlusCardFooterElement: {
        prototype: HTMLPlusCardFooterElement;
        new (): HTMLPlusCardFooterElement;
    };
    interface HTMLPlusCardHeaderElement extends Components.PlusCardHeader, HTMLStencilElement {
    }
    var HTMLPlusCardHeaderElement: {
        prototype: HTMLPlusCardHeaderElement;
        new (): HTMLPlusCardHeaderElement;
    };
    interface HTMLPlusClickOutsideElement extends Components.PlusClickOutside, HTMLStencilElement {
    }
    var HTMLPlusClickOutsideElement: {
        prototype: HTMLPlusClickOutsideElement;
        new (): HTMLPlusClickOutsideElement;
    };
    interface HTMLPlusCropperElement extends Components.PlusCropper, HTMLStencilElement {
    }
    var HTMLPlusCropperElement: {
        prototype: HTMLPlusCropperElement;
        new (): HTMLPlusCropperElement;
    };
    interface HTMLPlusDialogElement extends Components.PlusDialog, HTMLStencilElement {
    }
    var HTMLPlusDialogElement: {
        prototype: HTMLPlusDialogElement;
        new (): HTMLPlusDialogElement;
    };
    interface HTMLPlusDialogBodyElement extends Components.PlusDialogBody, HTMLStencilElement {
    }
    var HTMLPlusDialogBodyElement: {
        prototype: HTMLPlusDialogBodyElement;
        new (): HTMLPlusDialogBodyElement;
    };
    interface HTMLPlusDialogContentElement extends Components.PlusDialogContent, HTMLStencilElement {
    }
    var HTMLPlusDialogContentElement: {
        prototype: HTMLPlusDialogContentElement;
        new (): HTMLPlusDialogContentElement;
    };
    interface HTMLPlusDialogFooterElement extends Components.PlusDialogFooter, HTMLStencilElement {
    }
    var HTMLPlusDialogFooterElement: {
        prototype: HTMLPlusDialogFooterElement;
        new (): HTMLPlusDialogFooterElement;
    };
    interface HTMLPlusDialogHeaderElement extends Components.PlusDialogHeader, HTMLStencilElement {
    }
    var HTMLPlusDialogHeaderElement: {
        prototype: HTMLPlusDialogHeaderElement;
        new (): HTMLPlusDialogHeaderElement;
    };
    interface HTMLPlusDialogTogglerElement extends Components.PlusDialogToggler, HTMLStencilElement {
    }
    var HTMLPlusDialogTogglerElement: {
        prototype: HTMLPlusDialogTogglerElement;
        new (): HTMLPlusDialogTogglerElement;
    };
    interface HTMLPlusDividerElement extends Components.PlusDivider, HTMLStencilElement {
    }
    var HTMLPlusDividerElement: {
        prototype: HTMLPlusDividerElement;
        new (): HTMLPlusDividerElement;
    };
    interface HTMLPlusDrawerElement extends Components.PlusDrawer, HTMLStencilElement {
    }
    var HTMLPlusDrawerElement: {
        prototype: HTMLPlusDrawerElement;
        new (): HTMLPlusDrawerElement;
    };
    interface HTMLPlusDrawerTogglerElement extends Components.PlusDrawerToggler, HTMLStencilElement {
    }
    var HTMLPlusDrawerTogglerElement: {
        prototype: HTMLPlusDrawerTogglerElement;
        new (): HTMLPlusDrawerTogglerElement;
    };
    interface HTMLPlusGridElement extends Components.PlusGrid, HTMLStencilElement {
    }
    var HTMLPlusGridElement: {
        prototype: HTMLPlusGridElement;
        new (): HTMLPlusGridElement;
    };
    interface HTMLPlusGridItemElement extends Components.PlusGridItem, HTMLStencilElement {
    }
    var HTMLPlusGridItemElement: {
        prototype: HTMLPlusGridItemElement;
        new (): HTMLPlusGridItemElement;
    };
    interface HTMLPlusIntersectionElement extends Components.PlusIntersection, HTMLStencilElement {
    }
    var HTMLPlusIntersectionElement: {
        prototype: HTMLPlusIntersectionElement;
        new (): HTMLPlusIntersectionElement;
    };
    interface HTMLPlusMenuElement extends Components.PlusMenu, HTMLStencilElement {
    }
    var HTMLPlusMenuElement: {
        prototype: HTMLPlusMenuElement;
        new (): HTMLPlusMenuElement;
    };
    interface HTMLPlusPortalElement extends Components.PlusPortal, HTMLStencilElement {
    }
    var HTMLPlusPortalElement: {
        prototype: HTMLPlusPortalElement;
        new (): HTMLPlusPortalElement;
    };
    interface HTMLPlusRippleElement extends Components.PlusRipple, HTMLStencilElement {
    }
    var HTMLPlusRippleElement: {
        prototype: HTMLPlusRippleElement;
        new (): HTMLPlusRippleElement;
    };
    interface HTMLPlusScrollIndicatorElement extends Components.PlusScrollIndicator, HTMLStencilElement {
    }
    var HTMLPlusScrollIndicatorElement: {
        prototype: HTMLPlusScrollIndicatorElement;
        new (): HTMLPlusScrollIndicatorElement;
    };
    interface HTMLPlusSpinnerElement extends Components.PlusSpinner, HTMLStencilElement {
    }
    var HTMLPlusSpinnerElement: {
        prototype: HTMLPlusSpinnerElement;
        new (): HTMLPlusSpinnerElement;
    };
    interface HTMLPlusStickyElement extends Components.PlusSticky, HTMLStencilElement {
    }
    var HTMLPlusStickyElement: {
        prototype: HTMLPlusStickyElement;
        new (): HTMLPlusStickyElement;
    };
    interface HTMLPlusSwitchElement extends Components.PlusSwitch, HTMLStencilElement {
    }
    var HTMLPlusSwitchElement: {
        prototype: HTMLPlusSwitchElement;
        new (): HTMLPlusSwitchElement;
    };
    interface HTMLPlusTabsElement extends Components.PlusTabs, HTMLStencilElement {
    }
    var HTMLPlusTabsElement: {
        prototype: HTMLPlusTabsElement;
        new (): HTMLPlusTabsElement;
    };
    interface HTMLPlusTabsBarElement extends Components.PlusTabsBar, HTMLStencilElement {
    }
    var HTMLPlusTabsBarElement: {
        prototype: HTMLPlusTabsBarElement;
        new (): HTMLPlusTabsBarElement;
    };
    interface HTMLPlusTabsPanelElement extends Components.PlusTabsPanel, HTMLStencilElement {
    }
    var HTMLPlusTabsPanelElement: {
        prototype: HTMLPlusTabsPanelElement;
        new (): HTMLPlusTabsPanelElement;
    };
    interface HTMLPlusTabsPanelsElement extends Components.PlusTabsPanels, HTMLStencilElement {
    }
    var HTMLPlusTabsPanelsElement: {
        prototype: HTMLPlusTabsPanelsElement;
        new (): HTMLPlusTabsPanelsElement;
    };
    interface HTMLPlusTabsTabElement extends Components.PlusTabsTab, HTMLStencilElement {
    }
    var HTMLPlusTabsTabElement: {
        prototype: HTMLPlusTabsTabElement;
        new (): HTMLPlusTabsTabElement;
    };
    interface HTMLPlusTemplateElement extends Components.PlusTemplate, HTMLStencilElement {
    }
    var HTMLPlusTemplateElement: {
        prototype: HTMLPlusTemplateElement;
        new (): HTMLPlusTemplateElement;
    };
    interface HTMLPlusToastElement extends Components.PlusToast, HTMLStencilElement {
    }
    var HTMLPlusToastElement: {
        prototype: HTMLPlusToastElement;
        new (): HTMLPlusToastElement;
    };
    interface HTMLPlusToastTogglerElement extends Components.PlusToastToggler, HTMLStencilElement {
    }
    var HTMLPlusToastTogglerElement: {
        prototype: HTMLPlusToastTogglerElement;
        new (): HTMLPlusToastTogglerElement;
    };
    interface HTMLPlusToolbarElement extends Components.PlusToolbar, HTMLStencilElement {
    }
    var HTMLPlusToolbarElement: {
        prototype: HTMLPlusToolbarElement;
        new (): HTMLPlusToolbarElement;
    };
    interface HTMLPlusToolbarSpacerElement extends Components.PlusToolbarSpacer, HTMLStencilElement {
    }
    var HTMLPlusToolbarSpacerElement: {
        prototype: HTMLPlusToolbarSpacerElement;
        new (): HTMLPlusToolbarSpacerElement;
    };
    interface HTMLPlusTooltipElement extends Components.PlusTooltip, HTMLStencilElement {
    }
    var HTMLPlusTooltipElement: {
        prototype: HTMLPlusTooltipElement;
        new (): HTMLPlusTooltipElement;
    };
    interface HTMLPlusTransitionElement extends Components.PlusTransition, HTMLStencilElement {
    }
    var HTMLPlusTransitionElement: {
        prototype: HTMLPlusTransitionElement;
        new (): HTMLPlusTransitionElement;
    };
    interface HTMLPlusTunnelConsumerElement extends Components.PlusTunnelConsumer, HTMLStencilElement {
    }
    var HTMLPlusTunnelConsumerElement: {
        prototype: HTMLPlusTunnelConsumerElement;
        new (): HTMLPlusTunnelConsumerElement;
    };
    interface HTMLElementTagNameMap {
        "plus-aspect-ratio": HTMLPlusAspectRatioElement;
        "plus-bottom-navigation": HTMLPlusBottomNavigationElement;
        "plus-bottom-navigation-item": HTMLPlusBottomNavigationItemElement;
        "plus-breadcrumb": HTMLPlusBreadcrumbElement;
        "plus-card": HTMLPlusCardElement;
        "plus-card-body": HTMLPlusCardBodyElement;
        "plus-card-footer": HTMLPlusCardFooterElement;
        "plus-card-header": HTMLPlusCardHeaderElement;
        "plus-click-outside": HTMLPlusClickOutsideElement;
        "plus-cropper": HTMLPlusCropperElement;
        "plus-dialog": HTMLPlusDialogElement;
        "plus-dialog-body": HTMLPlusDialogBodyElement;
        "plus-dialog-content": HTMLPlusDialogContentElement;
        "plus-dialog-footer": HTMLPlusDialogFooterElement;
        "plus-dialog-header": HTMLPlusDialogHeaderElement;
        "plus-dialog-toggler": HTMLPlusDialogTogglerElement;
        "plus-divider": HTMLPlusDividerElement;
        "plus-drawer": HTMLPlusDrawerElement;
        "plus-drawer-toggler": HTMLPlusDrawerTogglerElement;
        "plus-grid": HTMLPlusGridElement;
        "plus-grid-item": HTMLPlusGridItemElement;
        "plus-intersection": HTMLPlusIntersectionElement;
        "plus-menu": HTMLPlusMenuElement;
        "plus-portal": HTMLPlusPortalElement;
        "plus-ripple": HTMLPlusRippleElement;
        "plus-scroll-indicator": HTMLPlusScrollIndicatorElement;
        "plus-spinner": HTMLPlusSpinnerElement;
        "plus-sticky": HTMLPlusStickyElement;
        "plus-switch": HTMLPlusSwitchElement;
        "plus-tabs": HTMLPlusTabsElement;
        "plus-tabs-bar": HTMLPlusTabsBarElement;
        "plus-tabs-panel": HTMLPlusTabsPanelElement;
        "plus-tabs-panels": HTMLPlusTabsPanelsElement;
        "plus-tabs-tab": HTMLPlusTabsTabElement;
        "plus-template": HTMLPlusTemplateElement;
        "plus-toast": HTMLPlusToastElement;
        "plus-toast-toggler": HTMLPlusToastTogglerElement;
        "plus-toolbar": HTMLPlusToolbarElement;
        "plus-toolbar-spacer": HTMLPlusToolbarSpacerElement;
        "plus-tooltip": HTMLPlusTooltipElement;
        "plus-transition": HTMLPlusTransitionElement;
        "plus-tunnel-consumer": HTMLPlusTunnelConsumerElement;
    }
}
declare namespace LocalJSX {
    interface PlusAspectRatio {
        /**
          * Specifies the ratio.
         */
        "value"?: AspectRatioValue;
    }
    interface PlusBottomNavigation {
        /**
          * TODO
         */
        "fixed"?: boolean;
        /**
          * TODO
         */
        "grow"?: boolean;
        /**
          * TODO
         */
        "hideOnScroll"?: boolean;
        /**
          * TODO
         */
        "labelPosition"?: 'bottom' | 'side';
        /**
          * TODO: https://vuetifyjs.com/en/components/bottom-navigation/#scroll-threshold
         */
        "scrollTarget"?: string;
        /**
          * TODO: https://vuetifyjs.com/en/components/bottom-navigation/#scroll-threshold
         */
        "scrollThreshold"?: number;
        /**
          * TODO https://vuetifyjs.com/en/components/bottom-navigation/#shift https://vuetifyjs.com/en/api/v-bottom-navigation/#props-shift
         */
        "shift"?: boolean;
        /**
          * TODO
         */
        "value"?: any;
    }
    interface PlusBottomNavigationItem {
        /**
          * TODO
         */
        "disabled"?: boolean;
        /**
          * TODO
         */
        "value"?: any;
    }
    interface PlusBreadcrumb {
        /**
          * For localization purposes, you can use the provided translations.
         */
        "expanderText"?: string;
        /**
          * Specifies Maximum items that is allowed to be displayed.
         */
        "max"?: number;
        /**
          * The expander button is displayed when the number of the items reached the maximum limit.  The offset property specifies the position of the expander button.
         */
        "offset"?: number;
        /**
          * You can use HTML elements, Custom separator, or SVG icon.
         */
        "separator"?: string;
    }
    interface PlusCard {
        /**
          * If you want the card to have shadow, use the elevation property,  And select the property value between `1` and `24`.
         */
        "elevation"?: CardElevation;
        /**
          * Use the flat property to neutralize elevation.
         */
        "flat"?: boolean;
        /**
          * If you want the card to have border, use the outlined property.
         */
        "outlined"?: boolean;
        /**
          * Use tile property to neutralize border-radius.
         */
        "tile"?: boolean;
    }
    interface PlusCardBody {
    }
    interface PlusCardFooter {
    }
    interface PlusCardHeader {
    }
    interface PlusClickOutside {
        /**
          * Disable the component.
         */
        "disabled"?: boolean;
        /**
          * Emitted when outside of the component is clicked.
         */
        "onPlusClickOutside"?: (event: CustomEvent<void>) => void;
        /**
          * The callback occurs only once.
         */
        "once"?: boolean;
    }
    interface PlusCropper {
        /**
          * A number between 0 and 1. Define the automatic cropping area size.
         */
        "area"?: number;
        /**
          * Defines the initial aspect ratio of the viewport.
         */
        "aspectRatio"?: number;
        /**
          * Shows the black modal above the image and under the viewport.
         */
        "backdrop"?: boolean;
        /**
          * Shows the grid background of the container.
         */
        "background"?: boolean;
        /**
          * Disables the cropper.
         */
        "disabled"?: boolean;
        /**
          * Shows the dashed lines above the viewport.
         */
        "guides"?: boolean;
        /**
          * Shows the center indicator above the viewport.
         */
        "indicator"?: boolean;
        /**
          * Defines the cropping mode of the cropper.
          * @value crop - Creates a new viewport and allows you to move and resize it.
          * @value move - moves the canvas and viewport.
         */
        "mode"?: CropperMode;
        /**
          * This event fires when the canvas or the viewport changed.
         */
        "onPlusCrop"?: (event: CustomEvent<void>) => void;
        /**
          * This event fires when the target image has been loaded and the cropper instance is ready for operating.
         */
        "onPlusReady"?: (event: CustomEvent<void>) => void;
        /**
          * This event fires when a cropper instance starts to zoom in or zoom out its canvas.
         */
        "onPlusZoom"?: (event: CustomEvent<CropperZoomData>) => void;
        /**
          * Enables to resize the viewport by dragging (Works when the value of the `mode` property is `crop`).
          * @value main - Enables to resize the viewport by dragging on the Sides.
          * @value edge - Enables to resize the viewport by dragging on the vertices.
          * @value both - Enables to resize the viewport by dragging on the Sides and vertices.
         */
        "resizer"?: CropperResizer;
        /**
          * Specifies the shape of the resizer.
         */
        "resizerShape"?: CropperResizerShape;
        /**
          * Re-renders the cropper when resizing the window.
          * @value reset - Restores the cropped area after resizing the window.
         */
        "responsive"?: CropperResponsive;
        /**
          * Specifies the shape of the viewport.
         */
        "shape"?: CropperShape;
        /**
          * Replace the image's src and rebuild the cropper.
         */
        "src"?: string;
        /**
          * The previous cropped data if you had stored, will be passed to value automatically when initialized.
         */
        "value"?: CropperValue;
        /**
          * Define the view mode of the cropper. If you set viewMode to `none`, the viewport can extend  outside the canvas, while a value of `fit`, `contain` or `cover` will restrict the viewport  to the size of the canvas. A viewMode of `contain` or `cover` will additionally restrict the  canvas to the container. Note that if the proportions of the canvas and the container are  the same, there is no difference between `contain` and `cover`.
          * @value contain - restrict the minimum canvas size to fit within the container. If the            proportions of the canvas and the container differ, the minimum canvas will be            surrounded by extra space in one of the dimensions.
          * @value cover   - restrict the minimum canvas size to fill fit the container. If the proportions            of the canvas and the container are different, the container will not be able            to fit the whole canvas in one of the dimensions.
          * @value fit     - restrict the viewport to not exceed the size of the canvas.
          * @value none    - no restrictions.
         */
        "view"?: CropperView;
        /**
          * Defines zoom ratio when zooming the image by wheeling mouse.
         */
        "zoomRatio"?: number;
        /**
          * Enables to zoom the image.
          * @value false - Unable to zoom the image.
          * @value true  - Enables to zoom the image by touching and wheeling mouse.
          * @value touch - Enables to zoom the image by touching.
          * @value wheel - Enables to zoom the image by wheeling mouse.
          * @
         */
        "zoomable"?: CropperZoomable;
    }
    interface PlusDialog {
        /**
          * TODO
         */
        "animation"?: string;
        /**
          * Activate the dialog's backdrop to show or not.
         */
        "backdrop"?: boolean;
        /**
          * This property helps you to attach which dialog toggler controls the dialog.  It doesn't matter where the dialog toggler is.  You can put the dialog's toggler inside or outside of the dialog.  Read more about connectors [here](https://htmlplus.io/features/connector).
         */
        "connector"?: string;
        /**
          * Set the height of the dialog as much as the screen's height.
         */
        "fullHeight"?: boolean;
        /**
          * Set the width of the dialog as much as the screen's width.
         */
        "fullWidth"?: boolean;
        /**
          * Set both width and height of the dialog to occupy the screen size.
         */
        "fullscreen"?: DialogFullscreen;
        /**
          * Closes the dialog when `escape` key is pressed.
         */
        "keyboard"?: boolean;
        /**
          * When the dialog is going to hide
         */
        "onPlusClose"?: (event: CustomEvent<void>) => void;
        /**
          * When the dialog is completely closed and its animation is completed.
         */
        "onPlusClosed"?: (event: CustomEvent<void>) => void;
        /**
          * When the dialog is going to show this event triggers
         */
        "onPlusOpen"?: (event: CustomEvent<void>) => void;
        /**
          * When the dialog is completely shown and its animation is completed.
         */
        "onPlusOpened"?: (event: CustomEvent<void>) => void;
        /**
          * Control dialog to show or not.
         */
        "open"?: boolean;
        /**
          * It prevents the dialog from closing on clicking outside of the element.
         */
        "persistent"?: boolean;
        /**
          * Specifies where to show the dialog box by choosing two values, one for horizontal and another for vertical. Horizontal has a range of `left`, `center`, `right`, `start`, `end`, and vertical values are `top`, `center` and `bottom`.
         */
        "placement"?: DialogPlacement;
        /**
          * Enables or disables the portal.
          * @experimental
         */
        "portal"?: boolean;
        /**
          * Specifies the position of the dialog.
          * @experimental
         */
        "portalStrategy"?: DialogPortalStrategy;
        /**
          * Specifies the position of the dialog relative to the target.
          * @experimental
         */
        "portalTarget"?: DialogPortalTarget;
        /**
          * It makes the user able to scroll the content by adding a scroll beside it.
         */
        "scrollable"?: boolean;
        /**
          * Determine the width of the dialog.
         */
        "size"?: DialogSize;
        /**
          * Removes the margin around the dialog's content.
         */
        "sticky"?: boolean;
    }
    interface PlusDialogBody {
        /**
          * It makes the user able to scroll the content by adding a scroll beside it.
         */
        "scrollable"?: boolean;
    }
    interface PlusDialogContent {
        /**
          * It makes the user able to scroll the content by adding a scroll beside it.
         */
        "scrollable"?: boolean;
    }
    interface PlusDialogFooter {
    }
    interface PlusDialogHeader {
    }
    interface PlusDialogToggler {
        /**
          * This property helps you to attach which dialog this toggler controls.  It doesn't matter where the dialog toggler is.  You can put the dialog's toggler inside or outside of the dialog.  Read more about connectors [here](https://htmlplus.io/features/connector).
         */
        "connector"?: string;
    }
    interface PlusDivider {
        /**
          * Determines the width of the divider.
         */
        "size"?: DividerSize;
        /**
          * Specifies different divider styles.
         */
        "type"?: DividerType;
        /**
          * You can use vertical property for vertical division.
         */
        "vertical"?: boolean;
    }
    interface PlusDrawer {
        /**
          * Activate the drawer's backdrop to show or not.
         */
        "backdrop"?: DrawerBackdrop;
        /**
          * Sets the mobile breakpoint to apply alternate styles for mobile devices when the breakpoint value is met.
         */
        "breakpoint"?: DrawerBreakpoint;
        /**
          * This property helps you to attach which drawer toggler controls the drawer.  It doesn't matter where the drawer toggler is.  You can put the drawer's toggler inside or outside of the drawer.  Read more about connectors [here](https://htmlplus.io/features/connector).
         */
        "connector"?: string;
        /**
          * It controls the flexibility of the drawer's width. If yes, the width of the drawer can be reduced. If false doesn't allow the width of the drawer to reduce.
         */
        "flexible"?: boolean;
        /**
          * Set the width of drawer to the minimum size you specified for the `mini-size` property.
         */
        "mini"?: boolean;
        /**
          * Sets the minimum width size of the drawer.
         */
        "miniSize"?: string;
        /**
          * When the drawer is going to hide
         */
        "onPlusClose"?: (event: CustomEvent<void>) => void;
        /**
          * When the drawer is completely closed and its animation is completed.
         */
        "onPlusClosed"?: (event: CustomEvent<void>) => void;
        /**
          * When the drawer is going to show this event triggers
         */
        "onPlusOpen"?: (event: CustomEvent<void>) => void;
        /**
          * When the drawer is completely shown and its animation is completed.
         */
        "onPlusOpened"?: (event: CustomEvent<void>) => void;
        /**
          * Control drawer to show or not.
         */
        "open"?: boolean;
        /**
          * If true, don't allow the drawer to be closed by clicking outside of the drawer. If false, the drawer will be closed by clicking outside of it.
         */
        "persistent"?: boolean;
        /**
          * Specifies where the drawer will open.
         */
        "placement"?: DrawerPlacement;
        /**
          * Determine the width of the drawer.
         */
        "size"?: string;
        /**
          * On default the drawer is considered as a part of the main container. it pushes the other contents on opening. If true it will be opened over other contents and doesn't affect other contents. A temporary drawer sits above its application and uses a backdrop to darken the background.
         */
        "temporary"?: boolean | 'on-breakpoint';
    }
    interface PlusDrawerToggler {
        /**
          * This property helps you to attach which drawer this toggler controls.  It doesn't matter where the drawer toggler is.  You can put the drawer's toggler inside or outside of the drawer.  Read more about connectors [here](https://htmlplus.io/features/connector).
         */
        "connector"?: string;
    }
    interface PlusGrid {
        /**
          * Aligns contents vertically across all rows (It overrides alignItems).
         */
        "alignContent"?: GridAlignContent;
        /**
          * Aligns contents vertically across all rows for large display sizes (It overrides alignItemsLg).
         */
        "alignContentLg"?: GridAlignContent;
        /**
          * Aligns contents vertically across all rows for medium display sizes (It overrides alignItemsMd).
         */
        "alignContentMd"?: GridAlignContent;
        /**
          * Aligns contents vertically across all rows for small display sizes (It overrides alignItemsSm).
         */
        "alignContentSm"?: GridAlignContent;
        /**
          * Aligns contents vertically across all rows for extra-large display sizes (It overrides alignItemsXl).
         */
        "alignContentXl"?: GridAlignContent;
        /**
          * Aligns contents vertically across all rows for extra-small display sizes (It overrides alignItemsXs).
         */
        "alignContentXs"?: GridAlignContent;
        /**
          * Aligns contents vertically across all rows for extra-extra-large display sizes (It overrides alignItemsXXl).
         */
        "alignContentXxl"?: GridAlignContent;
        /**
          * Aligns contents vertically inside their own row.
         */
        "alignItems"?: GridAlignItems;
        /**
          * Aligns contents vertically inside their own row for large display sizes.
         */
        "alignItemsLg"?: GridAlignItems;
        /**
          * Aligns contents vertically inside their own row for medium display sizes.
         */
        "alignItemsMd"?: GridAlignItems;
        /**
          * Aligns contents vertically inside their own row for small display sizes.
         */
        "alignItemsSm"?: GridAlignItems;
        /**
          * Aligns contents vertically inside their own row for extra-large display sizes.
         */
        "alignItemsXl"?: GridAlignItems;
        /**
          * Aligns contents vertically inside their own row for extra-small display sizes.
         */
        "alignItemsXs"?: GridAlignItems;
        /**
          * Aligns contents vertically inside their own row for extra-extra-large display sizes.
         */
        "alignItemsXxl"?: GridAlignItems;
        /**
          * Adds a gap between contents to make space between them vertically and horizontally.
         */
        "gutter"?: GridGutter;
        /**
          * Adds a gap between contents to make space between them horizontally.
         */
        "gutterX"?: GridGutter;
        /**
          * Adds a gap between contents to make space between them vertically.
         */
        "gutterY"?: GridGutter;
        /**
          * Justifies contents horizontally.
         */
        "justifyContent"?: GridJustifyContent;
        /**
          * Justifies contents horizontally for large display sizes.
         */
        "justifyContentLg"?: GridJustifyContent;
        /**
          * Justifies contents horizontally for medium display sizes.
         */
        "justifyContentMd"?: GridJustifyContent;
        /**
          * Justifies contents horizontally for small display sizes.
         */
        "justifyContentSm"?: GridJustifyContent;
        /**
          * Justifies contents horizontally for extra-large display sizes.
         */
        "justifyContentXl"?: GridJustifyContent;
        /**
          * Justifies contents horizontally for extra-small display sizes.
         */
        "justifyContentXs"?: GridJustifyContent;
        /**
          * Justifies contents horizontally for extra-extra-large display sizes.
         */
        "justifyContentXxl"?: GridJustifyContent;
        /**
          * Reverses the flow of contents from left-to-right to right-to-left, or vice-versa.
         */
        "reverse"?: boolean;
        /**
          * Changes the flow of contents from left-to-right to top-to-down.
         */
        "vertical"?: boolean;
        /**
          * Controls allowing the container to wrap the content or not if the cumulative width size of contents is more than the twelve-column width.
         */
        "wrap"?: GridWrap;
        /**
          * Controls allowing the container to wrap the content or not if the cumulative width size of contents is more than the twelve-column width for large screen devices.
         */
        "wrapLg"?: GridWrap;
        /**
          * Controls allowing the container to wrap the content or not if the cumulative width size of contents is more than the twelve-column width for medium screen devices.
         */
        "wrapMd"?: GridWrap;
        /**
          * Controls allowing the container to wrap the content or not if the cumulative width size of contents is more than the twelve-column width for small screen devices.
         */
        "wrapSm"?: GridWrap;
        /**
          * Controls allowing the container to wrap the content or not if the cumulative width size of contents is more than the twelve-column width for extra-large screen devices.
         */
        "wrapXl"?: GridWrap;
        /**
          * Controls allowing the container to wrap the content or not if the cumulative width size of contents is more than the twelve-column width for extra-small screen devices.
         */
        "wrapXs"?: GridWrap;
        /**
          * Controls allowing the container to wrap the content or not if the cumulative width size of contents is more than the twelve-column width for extra-extra-large screen devices.
         */
        "wrapXxl"?: GridWrap;
    }
    interface PlusGridItem {
        /**
          * Aligns the grid-item vertically in its container (grid). It overrides the align-items property of its parent.
         */
        "alignSelf"?: GridItemAlignSelf;
        /**
          * Aligns the grid-item vertically in its container (grid) for large display sizes. It also applies to larger breakpoints and display sizes while they are not specified. (It overrides the align-items property of its parent just for large breakpoints).
         */
        "alignSelfLg"?: GridItemAlignSelf;
        /**
          * Aligns the grid-item vertically in its container (grid) for medium display sizes. It also applies to larger breakpoints and display sizes while they are not specified. (It overrides the align-items property of its parent just for medium breakpoints).
         */
        "alignSelfMd"?: GridItemAlignSelf;
        /**
          * Aligns the grid-item vertically in its container (grid) for small display sizes. It also applies to larger breakpoints and display sizes while they are not specified. (It overrides the align-items property of its parent just for small breakpoints).
         */
        "alignSelfSm"?: GridItemAlignSelf;
        /**
          * Aligns the grid-item vertically in its container (grid) for extra-large display sizes. It also applies to larger breakpoints and display sizes while they are not specified. (It overrides the align-items property of its parent just for extra-large breakpoints).
         */
        "alignSelfXl"?: GridItemAlignSelf;
        /**
          * Aligns the grid-item vertically in its container (grid) for extra-small display sizes. It also applies to larger breakpoints and display sizes while they are not specified. (It overrides the align-items property of its parent just for extra-small breakpoints).
         */
        "alignSelfXs"?: GridItemAlignSelf;
        /**
          * Aligns the grid-item vertically in its container (grid) for extra-extra-large display sizes. It also applies to larger breakpoints and display sizes while they are not specified. (It overrides the align-items property of its parent just for extra-extra-large breakpoints).
         */
        "alignSelfXxl"?: GridItemAlignSelf;
        /**
          * Hides the grid-item in all display sizes.
         */
        "hide"?: boolean;
        /**
          * Hides the grid-item in large display sizes (desktop).
         */
        "hideLg"?: boolean;
        /**
          * Hides the grid-item in large and smaller display sizes.
         */
        "hideLgDown"?: boolean;
        /**
          * Hides the grid-item in large and larger display sizes.
         */
        "hideLgUp"?: boolean;
        /**
          * Hides the grid-item in medium display sizes (tablets).
         */
        "hideMd"?: boolean;
        /**
          * Hides the grid-item in medium and smaller display sizes.
         */
        "hideMdDown"?: boolean;
        /**
          * Hides the grid-item in medium and larger display sizes.
         */
        "hideMdUp"?: boolean;
        /**
          * Hides the grid-item in small display sizes (landscape phones).
         */
        "hideSm"?: boolean;
        /**
          * Hides the grid-item in small and smaller display sizes.
         */
        "hideSmDown"?: boolean;
        /**
          * Hides the grid-item in small and larger display sizes.
         */
        "hideSmUp"?: boolean;
        /**
          * Hides the grid-item in extra-large display sizes (large desktops).
         */
        "hideXl"?: boolean;
        /**
          * Hides the grid-item in large and smaller display sizes.
         */
        "hideXlDown"?: boolean;
        /**
          * Hides the grid-item in large and larger display sizes.
         */
        "hideXlUp"?: boolean;
        /**
          * Hides the grid-item in extra-small display sizes (portrait phones).
         */
        "hideXs"?: boolean;
        /**
          * Hides the grid-item in extra-extra-large display sizes (larger desktops).
         */
        "hideXxl"?: boolean;
        /**
          * Hides the grid-item in large and smaller display sizes.
         */
        "hideXxlDown"?: boolean;
        /**
          * Specifies the number of columns for large viewports (desktop). It also determines the number of columns for bigger display sizes when the upper breakpoint (xl and xxl) is not specified.
         */
        "lg"?: GridItemColumn;
        /**
          * Specifies the number of columns for medium viewports (tablets). It also determines the number of columns for bigger display sizes when other upper breakpoints (lg, xl and xxl) are not specified.
         */
        "md"?: GridItemColumn;
        /**
          * Adds an offset space before the grid-item for large display sizes. It also applies to the larger breakpoint (xl) while that is not specified.
         */
        "offsetLg"?: GridItemOffset;
        /**
          * Adds an offset space before the grid-item for medium display sizes. It also applies to larger breakpoints and display sizes while they are not specified.
         */
        "offsetMd"?: GridItemOffset;
        /**
          * Adds an offset space before the grid-item for small display sizes. It also applies to larger breakpoints and display sizes while they are not specified.
         */
        "offsetSm"?: GridItemOffset;
        /**
          * Adds an offset space before the grid-item for extra-large display sizes.
         */
        "offsetXl"?: GridItemOffset;
        /**
          * Adds an offset space before the grid-item for extra-small display sizes. It also applies to larger breakpoints and display sizes while they are not specified.
         */
        "offsetXs"?: GridItemOffset;
        /**
          * Adds an offset space before the grid-item for extra-extra-large display sizes.
         */
        "offsetXxl"?: GridItemOffset;
        /**
          * Overrides the default order of the grid-item for large display sizes. It also applies to the larger breakpoint (xl) while that is not specified.
         */
        "orderLg"?: GridItemOrder;
        /**
          * Overrides the default order of the grid-item for medium display sizes. It also applies to larger breakpoints and display sizes while they are not specified.
         */
        "orderMd"?: GridItemOrder;
        /**
          * Overrides the default order of the grid-item for small display sizes. It also applies to larger breakpoints and display sizes while they are not specified.
         */
        "orderSm"?: GridItemOrder;
        /**
          * Overrides the default order of the grid-item for extra-large display sizes.
         */
        "orderXl"?: GridItemOrder;
        /**
          * Overrides the default order of the grid-item for extra-small display sizes. It also applies to larger breakpoints and display sizes while they are not specified.
         */
        "orderXs"?: GridItemOrder;
        /**
          * Overrides the default order of the grid-item for extra-extra-large display sizes.
         */
        "orderXxl"?: GridItemOrder;
        /**
          * Specifies the number of columns for small viewports (landscape phones). It also determines the number of columns for bigger display sizes when other upper breakpoints (md, lg, xl and xxl) are not specified.
         */
        "sm"?: GridItemColumn;
        /**
          * Specifies the number of columns for large viewports (large desktops). It also determines the number of columns for bigger display sizes when the upper breakpoint (xxl) is not specified.
         */
        "xl"?: GridItemColumn;
        /**
          * Specifies the number of columns for extra-small viewports (portrait phones). It also determines the number of columns for bigger display sizes when other upper breakpoints (sm, md, lg, xl and xxl) are not specified.
         */
        "xs"?: GridItemColumn;
        /**
          * Specifies the number of columns for extra-extra-large viewports (larger desktops).
         */
        "xxl"?: GridItemColumn;
    }
    interface PlusIntersection {
        /**
          * It specifies how intersection behaves with its children.
          * @value normal - It doesn't have any effect on its children and the life cycles happen normally.
          * @value appear - The children are removed from the first moment, and then they're brought back in when the element intersects with the viewport. In other words, the children are added to the DOM when the element intersects with the viewport and they are removed when the element leaves the viewport.
          * @value blink  - The children are removed from the DOM when the element intersects with the viewport and are brought back in the DOM immediately. With that said, it affects the life cycles of its children.
         */
        "behavior"?: IntersectionBehavior;
        /**
          * Disables the intersection's trigger.
         */
        "disabled"?: boolean;
        /**
          * This event is triggered when its children intersects with the viewport in either coming to the viewport or going out of it.
         */
        "onPlusChange"?: (event: CustomEvent<IntersectionObserverEntry>) => void;
        /**
          * It causes the callback to be called just once for the first time.
         */
        "once"?: boolean;
        /**
          * The element that is used as the viewport for checking visibility of the target. Must be the ancestor of the target.  Defaults to the browser viewport if not specified or if null.
         */
        "root"?: Element;
        /**
          * Margin around the root. Can have values similar to the CSS [margin](https://developer.mozilla.org/en-US/docs/Web/CSS/margin) property, e.g.  "10px 20px 30px 40px" (top, right, bottom, left). The values can be percentages.  This set of values serves to grow or shrink each side of the root element's bounding box before computing intersections.  Defaults to all zeros.
         */
        "rootMargin"?: string;
        /**
          * Either a single number or an array of numbers which indicate at what percentage of the target's visibility the observer's callback should be executed.  If you only want to detect when visibility passes the 50% mark, you can use a value of 0.5.  If you want the callback to run every time visibility passes another 25%, you would specify the array [0, 0.25, 0.5, 0.75, 1].  The default is 0 (meaning as soon as even one pixel is visible, the callback will be run).  A value of 1.0 means that the threshold isn't considered passed until every pixel is visible.
         */
        "threshold"?: number | number[];
    }
    interface PlusMenu {
        /**
          * TODO
         */
        "alignX"?: MenuAlignX;
        /**
          * TODO
         */
        "alignY"?: MenuAlignY;
        /**
          * TODO
         */
        "fixed"?: boolean;
        /**
          * TODO
         */
        "growX"?: MenuGrowX;
        /**
          * TODO
         */
        "growY"?: MenuGrowY;
        /**
          * TODO
         */
        "offsetX"?: string | number;
        /**
          * TODO
         */
        "offsetY"?: string | number;
        /**
          * TODO
         */
        "onPlusClose"?: (event: CustomEvent<void>) => void;
        /**
          * TODO
         */
        "open"?: boolean;
        /**
          * TODO
         */
        "persistent"?: boolean;
        /**
          * TODO
         */
        "trigger"?: 'click' | 'hover';
    }
    interface PlusPortal {
        /**
          * Disables the portal.
         */
        "disabled"?: boolean;
        /**
          * Specifies the position of the portal content relative to the target.
         */
        "strategy"?: PortalStrategy;
        /**
          * Specifies the position of the portal content, It Can include css selectors, node or any html elements.
         */
        "target"?: PortalTarget;
    }
    interface PlusRipple {
    }
    interface PlusScrollIndicator {
        /**
          * Disables the event.
         */
        "disabled"?: boolean;
        /**
          * When the children is scrolled this event trigger.
         */
        "onPlusScroll"?: (event: CustomEvent<number>) => void;
        /**
          * Source of scroll.
         */
        "source"?: ScrollIndicatorSource;
    }
    interface PlusSpinner {
        /**
          * Specifies the size of the spinner.
         */
        "size"?: SpinnerSize;
        /**
          * Specifies which variant of the spinner to use.
         */
        "type"?: SpinnerType;
    }
    interface PlusSticky {
        /**
          * Disables the sticky mode.
         */
        "disabled"?: boolean;
        /**
          * When the component state is changed this event triggers.  To enable this event you shold set `watcher` property to `true`.
         */
        "onPlusChange"?: (event: CustomEvent<StickyState>) => void;
        /**
          * Specifies the space from top.
         */
        "top"?: StickyTop;
        /**
          * If you use `state` property or `plusChange` event, you shold set this property to `true`.
         */
        "watcher"?: boolean;
        /**
          * Specifies the z-index of the sticky.
         */
        "zIndex"?: number;
    }
    interface PlusSwitch {
        /**
          * Puts the switch in checked state
         */
        "checked"?: boolean;
        /**
          * Disables the switch
         */
        "disabled"?: boolean;
        /**
          * Change the appearance of the switch to put the text inside the switch
         */
        "inset"?: boolean;
        /**
          * When the switch state is changed this event triggers.
         */
        "onPlusChange"?: (event: CustomEvent<void>) => void;
        /**
          * Switches the location of yes and no options
         */
        "reverse"?: boolean;
    }
    interface PlusTabs {
        /**
          * TODO
         */
        "connector"?: string;
        /**
          * TODO
         */
        "onWowChange"?: (event: CustomEvent<string>) => void;
        /**
          * TODO
         */
        "value"?: string;
        /**
          * TODO
         */
        "vertical"?: boolean;
    }
    interface PlusTabsBar {
        /**
          * TODO
         */
        "grow"?: boolean;
        /**
          * TODO
         */
        "justify"?: 'start' | 'center' | 'end';
        /**
          * TODO
         */
        "reverse"?: boolean;
    }
    interface PlusTabsPanel {
        /**
          * TODO
         */
        "value"?: string;
    }
    interface PlusTabsPanels {
        /**
          * TODO
         */
        "connector"?: string;
    }
    interface PlusTabsTab {
        /**
          * TODO
         */
        "disabled"?: boolean;
        /**
          * TODO
         */
        "value"?: string;
    }
    interface PlusTemplate {
        /**
          * TODO
         */
        "disabled"?: boolean;
    }
    interface PlusToast {
        /**
          * TODO
         */
        "animation"?: string;
        /**
          * TODO
         */
        "duration"?: number;
        /**
          * TODO
         */
        "fullWidth"?: boolean;
        /**
          * TODO
         */
        "onPlusClose"?: (event: CustomEvent<void>) => void;
        /**
          * TODO
         */
        "onPlusClosed"?: (event: CustomEvent<void>) => void;
        /**
          * TODO
         */
        "onPlusOpen"?: (event: CustomEvent<void>) => void;
        /**
          * TODO
         */
        "onPlusOpened"?: (event: CustomEvent<void>) => void;
        /**
          * TODO
         */
        "open"?: boolean;
        /**
          * TODO
         */
        "persistent"?: boolean;
        /**
          * TODO
         */
        "placement"?: ToastPlacement;
        /**
          * TODO
         */
        "reverse"?: boolean;
        /**
          * TODO
         */
        "type"?: ToastType;
    }
    interface PlusToastToggler {
        /**
          * This property helps you to attach which toast this toggler controls.  It doesn't matter where the toast toggler is.  You can put the toast's toggler inside or outside of the toast.  Read more about connectors [here](https://htmlplus.io/features/connector).
         */
        "connector"?: string;
    }
    interface PlusToolbar {
        /**
          * TODO
         */
        "disabled"?: boolean;
    }
    interface PlusToolbarSpacer {
        /**
          * TODO
         */
        "disabled"?: boolean;
    }
    interface PlusTooltip {
        /**
          * Tooltip animation.
         */
        "animation"?: TooltipAnimation;
        /**
          * Tooltip append to a element.
         */
        "appendTo"?: any;
        /**
          * Tooltip arrow model.
         */
        "arrow"?: TooltipArrow;
        /**
          * Delay for show tooltip.
         */
        "delay"?: number;
        /**
          * Tooltip disable.
         */
        "disabled"?: boolean;
        /**
          * Add fixed strategy to popper.
         */
        "fixed"?: boolean;
        /**
          * Add fixed strategy to popper.
         */
        "flip"?: boolean;
        /**
          * How to position the tooltip.
         */
        "placement"?: TooltipPlacement;
        /**
          * How tooltip is triggered, include click, hover, focus.
         */
        "trigger"?: TooltipTrigger;
    }
    interface PlusTransition {
        /**
          * Specifies the amount of delay before starting the animation to play.  This may be specified in either seconds `s` or milliseconds `ms`.
         */
        "delay"?: string;
        /**
          * Defines whether an animation should be played forwards, backwards or in alternate cycles.
         */
        "direction"?: TransitionDirection;
        /**
          * Specifies the length of time it will take to complete one cycle between two defined states. You can also use the reservation values `slower`, `slow`, `normal`, `fast` and `faster`.
         */
        "duration"?: TransitionDuration;
        /**
          * Specifies what kind of animation you want to play.  click [here](ROUTE:COMPONENT:TRANSITION:PROPERTY:NAME) to see the list of available animations.
         */
        "name"?: string;
        /**
          * This event is fired any time the animation has been canceled.
         */
        "onPlusCancel"?: (event: CustomEvent<void>) => void;
        /**
          * This event is fired when animation has been completed.
         */
        "onPlusEnd"?: (event: CustomEvent<void>) => void;
        /**
          * This event is fired any time a new cycle has been started.
         */
        "onPlusIteration"?: (event: CustomEvent<void>) => void;
        /**
          * This event is fired when animation has been started.
         */
        "onPlusStart"?: (event: CustomEvent<void>) => void;
        /**
          * Specifies the number of times the animation should be repeated after one complete cycle.
         */
        "repeat"?: TransitionRepeat;
    }
    interface PlusTunnelConsumer {
        "context"?: { [key: string]: any };
        "renderer"?: Function;
        "subscribe"?: SubscribeType;
    }
    interface IntrinsicElements {
        "plus-aspect-ratio": PlusAspectRatio;
        "plus-bottom-navigation": PlusBottomNavigation;
        "plus-bottom-navigation-item": PlusBottomNavigationItem;
        "plus-breadcrumb": PlusBreadcrumb;
        "plus-card": PlusCard;
        "plus-card-body": PlusCardBody;
        "plus-card-footer": PlusCardFooter;
        "plus-card-header": PlusCardHeader;
        "plus-click-outside": PlusClickOutside;
        "plus-cropper": PlusCropper;
        "plus-dialog": PlusDialog;
        "plus-dialog-body": PlusDialogBody;
        "plus-dialog-content": PlusDialogContent;
        "plus-dialog-footer": PlusDialogFooter;
        "plus-dialog-header": PlusDialogHeader;
        "plus-dialog-toggler": PlusDialogToggler;
        "plus-divider": PlusDivider;
        "plus-drawer": PlusDrawer;
        "plus-drawer-toggler": PlusDrawerToggler;
        "plus-grid": PlusGrid;
        "plus-grid-item": PlusGridItem;
        "plus-intersection": PlusIntersection;
        "plus-menu": PlusMenu;
        "plus-portal": PlusPortal;
        "plus-ripple": PlusRipple;
        "plus-scroll-indicator": PlusScrollIndicator;
        "plus-spinner": PlusSpinner;
        "plus-sticky": PlusSticky;
        "plus-switch": PlusSwitch;
        "plus-tabs": PlusTabs;
        "plus-tabs-bar": PlusTabsBar;
        "plus-tabs-panel": PlusTabsPanel;
        "plus-tabs-panels": PlusTabsPanels;
        "plus-tabs-tab": PlusTabsTab;
        "plus-template": PlusTemplate;
        "plus-toast": PlusToast;
        "plus-toast-toggler": PlusToastToggler;
        "plus-toolbar": PlusToolbar;
        "plus-toolbar-spacer": PlusToolbarSpacer;
        "plus-tooltip": PlusTooltip;
        "plus-transition": PlusTransition;
        "plus-tunnel-consumer": PlusTunnelConsumer;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            "plus-aspect-ratio": LocalJSX.PlusAspectRatio & JSXBase.HTMLAttributes<HTMLPlusAspectRatioElement>;
            "plus-bottom-navigation": LocalJSX.PlusBottomNavigation & JSXBase.HTMLAttributes<HTMLPlusBottomNavigationElement>;
            "plus-bottom-navigation-item": LocalJSX.PlusBottomNavigationItem & JSXBase.HTMLAttributes<HTMLPlusBottomNavigationItemElement>;
            "plus-breadcrumb": LocalJSX.PlusBreadcrumb & JSXBase.HTMLAttributes<HTMLPlusBreadcrumbElement>;
            "plus-card": LocalJSX.PlusCard & JSXBase.HTMLAttributes<HTMLPlusCardElement>;
            "plus-card-body": LocalJSX.PlusCardBody & JSXBase.HTMLAttributes<HTMLPlusCardBodyElement>;
            "plus-card-footer": LocalJSX.PlusCardFooter & JSXBase.HTMLAttributes<HTMLPlusCardFooterElement>;
            "plus-card-header": LocalJSX.PlusCardHeader & JSXBase.HTMLAttributes<HTMLPlusCardHeaderElement>;
            "plus-click-outside": LocalJSX.PlusClickOutside & JSXBase.HTMLAttributes<HTMLPlusClickOutsideElement>;
            "plus-cropper": LocalJSX.PlusCropper & JSXBase.HTMLAttributes<HTMLPlusCropperElement>;
            "plus-dialog": LocalJSX.PlusDialog & JSXBase.HTMLAttributes<HTMLPlusDialogElement>;
            "plus-dialog-body": LocalJSX.PlusDialogBody & JSXBase.HTMLAttributes<HTMLPlusDialogBodyElement>;
            "plus-dialog-content": LocalJSX.PlusDialogContent & JSXBase.HTMLAttributes<HTMLPlusDialogContentElement>;
            "plus-dialog-footer": LocalJSX.PlusDialogFooter & JSXBase.HTMLAttributes<HTMLPlusDialogFooterElement>;
            "plus-dialog-header": LocalJSX.PlusDialogHeader & JSXBase.HTMLAttributes<HTMLPlusDialogHeaderElement>;
            "plus-dialog-toggler": LocalJSX.PlusDialogToggler & JSXBase.HTMLAttributes<HTMLPlusDialogTogglerElement>;
            "plus-divider": LocalJSX.PlusDivider & JSXBase.HTMLAttributes<HTMLPlusDividerElement>;
            "plus-drawer": LocalJSX.PlusDrawer & JSXBase.HTMLAttributes<HTMLPlusDrawerElement>;
            "plus-drawer-toggler": LocalJSX.PlusDrawerToggler & JSXBase.HTMLAttributes<HTMLPlusDrawerTogglerElement>;
            "plus-grid": LocalJSX.PlusGrid & JSXBase.HTMLAttributes<HTMLPlusGridElement>;
            "plus-grid-item": LocalJSX.PlusGridItem & JSXBase.HTMLAttributes<HTMLPlusGridItemElement>;
            "plus-intersection": LocalJSX.PlusIntersection & JSXBase.HTMLAttributes<HTMLPlusIntersectionElement>;
            "plus-menu": LocalJSX.PlusMenu & JSXBase.HTMLAttributes<HTMLPlusMenuElement>;
            "plus-portal": LocalJSX.PlusPortal & JSXBase.HTMLAttributes<HTMLPlusPortalElement>;
            "plus-ripple": LocalJSX.PlusRipple & JSXBase.HTMLAttributes<HTMLPlusRippleElement>;
            "plus-scroll-indicator": LocalJSX.PlusScrollIndicator & JSXBase.HTMLAttributes<HTMLPlusScrollIndicatorElement>;
            "plus-spinner": LocalJSX.PlusSpinner & JSXBase.HTMLAttributes<HTMLPlusSpinnerElement>;
            "plus-sticky": LocalJSX.PlusSticky & JSXBase.HTMLAttributes<HTMLPlusStickyElement>;
            "plus-switch": LocalJSX.PlusSwitch & JSXBase.HTMLAttributes<HTMLPlusSwitchElement>;
            "plus-tabs": LocalJSX.PlusTabs & JSXBase.HTMLAttributes<HTMLPlusTabsElement>;
            "plus-tabs-bar": LocalJSX.PlusTabsBar & JSXBase.HTMLAttributes<HTMLPlusTabsBarElement>;
            "plus-tabs-panel": LocalJSX.PlusTabsPanel & JSXBase.HTMLAttributes<HTMLPlusTabsPanelElement>;
            "plus-tabs-panels": LocalJSX.PlusTabsPanels & JSXBase.HTMLAttributes<HTMLPlusTabsPanelsElement>;
            "plus-tabs-tab": LocalJSX.PlusTabsTab & JSXBase.HTMLAttributes<HTMLPlusTabsTabElement>;
            "plus-template": LocalJSX.PlusTemplate & JSXBase.HTMLAttributes<HTMLPlusTemplateElement>;
            "plus-toast": LocalJSX.PlusToast & JSXBase.HTMLAttributes<HTMLPlusToastElement>;
            "plus-toast-toggler": LocalJSX.PlusToastToggler & JSXBase.HTMLAttributes<HTMLPlusToastTogglerElement>;
            "plus-toolbar": LocalJSX.PlusToolbar & JSXBase.HTMLAttributes<HTMLPlusToolbarElement>;
            "plus-toolbar-spacer": LocalJSX.PlusToolbarSpacer & JSXBase.HTMLAttributes<HTMLPlusToolbarSpacerElement>;
            "plus-tooltip": LocalJSX.PlusTooltip & JSXBase.HTMLAttributes<HTMLPlusTooltipElement>;
            "plus-transition": LocalJSX.PlusTransition & JSXBase.HTMLAttributes<HTMLPlusTransitionElement>;
            "plus-tunnel-consumer": LocalJSX.PlusTunnelConsumer & JSXBase.HTMLAttributes<HTMLPlusTunnelConsumerElement>;
        }
    }
}
